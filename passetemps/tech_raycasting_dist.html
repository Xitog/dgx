<!doctype html>
<html lang="fr" onmouseleave="out();" onmouseenter="inside();">
  <head>
    <meta charset="utf-8">
    <title>FPS 2.5D</title>
    <script type="text/javascript" src="common.js"></script>
  </head>
  <body onload="start();">
      <form>
      x = <input id="x" type="text" value="9.5"/>
      y = <input id="y" type="text" value="12"/>   <!-- 7.5 -->
      a = <input id="a" type="text" value="0"/>
      <input type="button" value="-" onclick="less('ang');"/>
      <input type="button" value="+" onclick="more('ang');"/>
      <i>(en degr√©)</i>
      <input type="button" value="ok" onclick="change();"/>
    </form>
    <br>
    <canvas id="screen2D" width="640" height="480">
      
    </canvas>
    &nbsp;
    <canvas id="screen3D" width="640" height="480">
      
    </canvas>
    <script type="text/javascript">
    var player_x = getFloat("x");
    var player_y = getFloat("y");
    var player_a = 90 * 0.01745; //0;
    var cos_a = Math.cos(player_a);
    var sin_a = Math.sin(player_a);
    var player_fov = 66 * 0.01745; // in rad
    
    var right = false;
    var left = false;
    var down = false;
    var up = false;
    
    var pause = false;
    
    var distances;
    var intersections;
    var intersections_map;
    
    // Debug
    //var rays = [0, 160, 320, 480, 639];
    //var rays = [320];
    
    var SCREEN_WIDTH = 640;
    var SCREEN_HEIGHT = 480;
    
    var colors = [
        'black',
        'red',
        'purple',
        'yellow'
    ];
    
    var map = [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 1],
        [1, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ];
    
    function less(p) {
        if (p === 'ang') {
            player_a -= 15 * 0.01745;
            cos_a = Math.cos(player_a);
            sin_a = Math.sin(player_a);
            setFloat("a", player_a * 57.2958);
        }
    }
    
    function more(p) {
        if (p === 'ang') {
            player_a += 15 * 0.01745;
            cos_a = Math.cos(player_a);
            sin_a = Math.sin(player_a);
            setFloat("a", player_a * 57.2958);
        }
    }
    
    function change() {
        player_a = getFloat("a") * 0.01745; // in rad
        player_x = getFloat("x");
        player_y = getFloat("y");
        cos_a = Math.cos(player_a);
        sin_a = Math.sin(player_a);
    }
    
    function start() {
        window.onkeydown = on_key_down;
        window.onkeyup = on_key_up;
        window.setInterval(run, 33);
        //document.addEventListener('keydown', io);
        //window.onfocusout = out;
        //window.onblur = out;
        document.mouseout = out;
        document.mouseleave = out;
    }
    
    function inside() {
        pause = false;
    }
    
    function out() {
        console.log(right);
        right = false;
        left = false;
        down = false;
        up = false;
        pause = true;
    }
    
    function on_key_down(event) {
        if (pause) { return; }
        if (event.key === 's') {
            down = true;
        } else if (event.key === 'z') {
            up = true;
        } else if (event.key === 'q') {
            left = true;
        } else if (event.key === 'd') {
            right = true;
        }
    }
    
    function on_key_up(event) {
        if (pause) { return; }
        if (event.key === 's') {
            down = false;
        } else if (event.key === 'z') {
            up = false;
        } else if (event.key === 'q') {
            left = false;
        } else if (event.key === 'd') {
            right = false;
        } else {
            console.log(event.key);
        }
    }
    
    function run() {
        update();
        draw();
    }
    
    function update() {
        let next_x = player_x;
        let next_y = player_y;
        if (down) {
            next_x -= cos_a * 0.1;
            next_y -= sin_a * 0.1;
        }
        if (up) {
            next_x += cos_a * 0.1;
            next_y += sin_a * 0.1;
        }
        if (right) {
            player_a += 0.05;
            cos_a = Math.cos(player_a);
            sin_a = Math.sin(player_a);
        }
        if (left) {
            player_a -= 0.05;
            cos_a = Math.cos(player_a);
            sin_a = Math.sin(player_a);
        }
        let next_x_map = Math.trunc(next_x);
        let next_y_map = Math.trunc(next_y);
        let player_x_map = Math.trunc(player_x);
        let player_y_map = Math.trunc(player_y);
        if (map[next_y_map][next_x_map] != 0) {
            if (map[next_y_map][player_x_map] == 0) {
                player_y = next_y;
            } else if (map[player_y_map][next_x_map] == 0) {
                player_x = next_x;
            }
        } else {
            player_x = next_x;
            player_y = next_y;
        }
    }
    
    function draw() {
        // Screen info
        let infos = init("screen2D");
        draw2D(infos.context);
        infos = init("screen3D");
        draw3D(infos.context);
    }

    function draw2D(ctx) {
        // Grid Drawing
        rect(ctx, 'lightgrey', 0, 0, 640, 480, true);
        rect(ctx, 'black', 0, 0, 639, 479, false);
        
        for (let row=0; row < 15; row++) {
          line(ctx, 'black', 0, row * 32, 639, row * 32);
        }
        
        for (let col=0; col < 20; col++) {
          line(ctx, 'black', col * 32, 0, col * 32, 479);
        }
        for (let row=0; row < 15; row++) {
            for (let col=0; col < 20; col++) {
                if (map[row][col] != 0) {
                    rect(ctx, 'lightblue', col * 32, row * 32, 32, 32, true);
                }
            }
        }
        // Player
        circle(ctx, 'red', player_x * 32, player_y * 32, 32);
        // Dir
        line(ctx, 'red', 
            player_x * 32, 
            player_y * 32, 
            (player_x + cos_a) * 32,
            (player_y + sin_a) * 32
        );
        // Camera Plane Calculating
        let n = Math.tan(player_fov / 2);
        let cam_x = -sin_a * n;
        let cam_y = cos_a * n;
        // Rays
        distances = [];
        intersections = [];
        intersections_map = [];
        for (let x = 0; x < SCREEN_WIDTH; x++) {
            // Debug
            //if (!rays.includes(x)) {
            //    distances.push(0);
            //    continue;
            //}
            
            let factor = (x / SCREEN_WIDTH) * 2 - 1;
            let ray_x = cos_a + factor * cam_x;
            let ray_y = sin_a + factor * cam_y;
            
            // DDA calc
            let delta_x;
            let step_map_x;
            if (ray_x < 0) {
                delta_x = Math.abs((player_x - Math.floor(player_x)) / ray_x);
                step_map_x = -1;
            } else {
                delta_x = Math.abs((Math.floor(player_x) + 1 - player_x) / ray_x);
                step_map_x = 1
            }
            let delta_y;
            let step_map_y;
            if (ray_y < 0) {
                delta_y = Math.abs((player_y - Math.floor(player_y)) / ray_y);
                step_map_y = -1;
            } else {
                delta_y = Math.abs((Math.floor(player_y) + 1 - player_y) / ray_y);
                step_map_y = 1;
            }
            
            let map_x = Math.floor(player_x);
            let map_y = Math.floor(player_y);
            
            let distance_x = Math.abs(1 / ray_x);
            let distance_y = Math.abs(1 / ray_y);
            
            let step_x = delta_x;
            let step_y = delta_y;

            let cumul_x = 0;
            let cumul_y = 0;
            
            let on_x = false; // if we are breaking in by x or y
            
            while (map_x >= 0 && map_y >= 0 && map_x < 20 && map_y < 15) {
              if (map[map_y][map_x] != 0) {
                break;
              }
              if (cumul_x + step_x < cumul_y + step_y) {
                cumul_x += step_x;
                step_x = distance_x;
                map_x += step_map_x;
                on_x = true;
              } else {
                cumul_y += step_y;
                step_y = distance_y;
                map_y += step_map_y;
                on_x = false;
              }
            }
            let d = Math.abs(n * factor);
            let angle = Math.atan(d);
            // Distance
            let dist_taken;
            let point;
            if (on_x) {
                dist_taken = cumul_x;
                if (ray_x < 0) {
                    point = [map_x + 1, player_y + ray_y * cumul_x];
                } else {
                    point = [map_x, player_y + ray_y * cumul_x];
                }
            } else {
                dist_taken = cumul_y;
                if (ray_y < 0) {
                    point = [player_x + ray_x * cumul_y, map_y + 1];
                } else {
                    point = [player_x + ray_x * cumul_y, map_y];
                }
            }
            distances.push(dist_taken);
            intersections.push(point);
            intersections_map.push({y : map_y, x : map_x});
            //let true_dist = Math.sqrt(Math.pow(player_x - point[0], 2) + Math.pow(player_y - point[1], 2));
            //if (Math.abs(true_dist - dist_taken) > 0.1) {
            //    console.log("diff=", Math.abs(true_dist - dist_taken), "true=", true_dist, "cumul=", dist_taken, step_x, step_y);
            //}
            //distances.push(Math.cos(angle) * dist_taken);
            
            line(ctx, 'green',
                player_x * 32,
                player_y * 32, 
                point[0] * 32, 
                point[1] * 32
            );
        }
        // Camera Plane Drawing
        line(ctx, 'yellow',
            (player_x + cos_a) * 32, 
            (player_y + sin_a) * 32, 
            (player_x + cos_a + cam_x) * 32, 
            (player_y + sin_a + cam_y) * 32
        );
        line(ctx, 'yellow', 
            (player_x + cos_a) * 32, 
            (player_y + sin_a) * 32, 
            (player_x + cos_a - cam_x) * 32, 
            (player_y + sin_a - cam_y) * 32
        );
        
        line(ctx, 'yellow',
            player_x * 32, 
            player_y * 32, 
            (player_x + cos_a + cam_x) * 32, 
            (player_y + sin_a + cam_y) * 32
        );
        line(ctx, 'yellow',
            player_x * 32, 
            player_y * 32, 
            (player_x + cos_a - cam_x) * 32, 
            (player_y + sin_a - cam_y) * 32
        );
    }
    
    function draw3D(ctx) {
        rect(ctx, 'black', 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, true);

        for (let col=0; col < SCREEN_WIDTH; col++) {
            let halfsize = Math.trunc((SCREEN_HEIGHT / distances[col]) / 2);
            let point = intersections_map[col];
            let color_index = map[point.y][point.x];
            let color = colors[color_index];
            line(ctx, color, col, SCREEN_HEIGHT / 2 - halfsize, col, SCREEN_HEIGHT / 2 + halfsize);
        }
        
        // Debug
        /*
        let halfsizes = [];
        for (let colx of rays) {
            halfsizes.push(Math.trunc((SCREEN_HEIGHT / distances[colx]) / 2));
        }
        for (let i = 0; i < halfsizes.length - 1; i++) {
            line(ctx, 'red', rays[i], SCREEN_HEIGHT / 2 - halfsizes[i], rays[i+1], SCREEN_HEIGHT / 2 - halfsizes[i+1]);
            line(ctx, 'red', rays[i], SCREEN_HEIGHT / 2 + halfsizes[i], rays[i+1], SCREEN_HEIGHT / 2 + halfsizes[i+1]);
        }
        */
    }
        
    </script>
  </body>
</html>
